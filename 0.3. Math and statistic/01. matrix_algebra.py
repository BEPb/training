#Pyton 3.9

# Обзор матричной алгебры

import numpy as np

x = np.array([1, 2, 3])
y = np.array([4, 5, 6])

### Поэлементные операции с массивами

print(x + y)

print(x * y)

print(x - y)

print(x / y)

# элементы массива x возводятся в соответствующие степени элементов массива y
print(x ** y)

# остаток от деления
# обратите внимание, что для удобства данного примера x и y идут в другом порядке

print(y % x)

### Изменение размерности

x = np.arange(0, 10)
print(x)

# 10 - количество строк
print(x.shape)

var = np.array(
    [
        [1, 2],
        [3, 4],
        [5, 6]
    ]
).shape

# первый аргумент - количество строк
# второй - столбцов

print(x.reshape(5, 2))

# при "неправильном" количестве строк и столбцов будет ошибка
# x.reshape(5, 3)

d = {'a': 1}
#d['b']

# если нужно, чтобы скрипт не вылетал с ошибкой, то можно так:
try:
    x.reshape(5, 3)
    x += '1'

except ValueError:
    print('Попались кривые данные, идем дальше')

except Exception as e:
    print('Неизвестная ошибка. Останавливаю выполнение')
    raise e

# транспонирование матриц

var = np.array(
    [
        [1, 2],
        [3, 4],
        [5, 6]
    ]
).T

# склеивание листов

x = np.array([[1, 2, 3], [4, 5, 6]])

x.ravel()

# можно и так

x.reshape(6)

# результат разный, если добавить 1 в качестве количества строк

var = x.reshape(1, 6)[0]

### Скалярное произведение векторов


a = np.array([4, 3])
b = np.array([2, 1])

# Пример расчета скалярного произведения векторов
np.dot(a, b)

# Можно посчитать и таким образом
# первый шаг

for pair in zip(a, b):
    print(pair)

# второй шаг
var = [pair[0] * pair[1] for pair in zip(a, b)]

# итоговый результат
sum([pair[0] * pair[1] for pair in zip(a, b)])

### Косинусное расстояние между векторами
import matplotlib.pyplot as plt

ax = plt.axes()

plt.xlim([0, 5])
plt.ylim([0, 4])

ax.arrow(0, 0, a[0], a[1], head_width=0.1, head_length=0.2, fc='k', ec='k')
ax.arrow(0, 0, b[0], b[1], head_width=0.1, head_length=0.2, fc='k', ec='k')

plt.show()


def cosine(a, b):
    """
    Подсчет косинуса угла между векторами a, b по их координатам
    """

    # длины векторов
    aLength = np.linalg.norm(a)
    bLength = np.linalg.norm(b)

    return np.dot(a, b) / (aLength * bLength)


# длины векторов можно было посчитать и так

aLength = np.sqrt((a * a).sum())
bLength = np.sqrt((b * b).sum())

cosine(a, b)

# угол между векторами в радианах

np.arccos(cosine(a, b))

# угол между векторами в градусах

np.arccos(cosine(a, b)) * 360 / 2 / np.pi

## Упражнение

# Имеется матрица покупок в интернет - магазине.Столбец А - ID пользователя.Остальные столбцы - количество
# покупок категорий товаров этим пользователем:

from IPython.display import Image

Image("user_matrix.JPG")

# Матрица в виде numpy array
users_stats = np.array(
    [
        [2, 1, 0, 0, 0, 0],
        [1, 1, 2, 1, 0, 0],
        [2, 0, 1, 0, 0, 0],
        [1, 1, 2, 1, 0, 1],
        [0, 0, 1, 2, 0, 0],
        [0, 0, 0, 0, 0, 5],
        [1, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 3],
        [1, 0, 0, 2, 1, 4]
    ],
    np.int32
)

# На сайт заходит очередной посетитель, о покупках которого известно следующее:
next_user_stats = np.array([0, 1, 2, 0, 0, 0])

# Посчитайте косинусное расстояние между этим пользователем и всеми пользователями из
# массива user_stats

### Перемножение матриц
# ** Определение **

# Пусть даны две матрицы a и b размером lxm и mxn
# соответственно. l - количество строк, n - количество столбцов.

# Тогда произведением матриц a и b будет матрица c размерностью l x n:

a = np.array(
    [
        [1, 2],
        [3, 4]
    ]
)

b = np.array(
    [
        [5, 6],
        [7, 8]
    ]
)

c11 = 1 * 5 + 2 * 7
print(c11)

c12 = 1 * 6 + 2 * 8
print(c12)

c = np.dot(a, b)
print(c)

# В numpy есть специальный тип matrix, который отличается от ndarray

aMatrix = np.matrix([[1, 2], [3, 4]])
bMatrix = np.matrix([[5, 6], [7, 8]])

aMatrix * bMatrix

a * b

type(aMatrix), type(a)

np.mat(a) * np.mat(b)

## Линейные уравнения

# Дана система линейных уравнений
# коэффициенты при переменных в левой части уравнения

a = np.array([[1, 3], [2, -4]])

# значения в правой части уравнения

b = np.array([9, 8])

# решение

answer = np.array([6., 1.])
print(answer)

# проверка верности

np.allclose(np.dot(a, answer), b)

## Определитель матрицы

a = np.array(
    [
        [1, 2],
        [3, 4]
    ]
)

np.linalg.det(a)

# как получить единичную матрицу

np.eye(5, dtype=int)

## Сингулярное разложение

# M - матрица mxn является сингулярным числом матрицы
# M, если существуют два вектора единичной длины u и v такие, что

# Сингулярное разложение:
